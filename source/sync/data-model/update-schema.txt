.. _update-your-data-model:
.. _destructive-changes-synced-schema:
.. _additive-changes-synced-schema:

======================
Update Your Data Model
======================

.. meta::
   :description: Learn how to update an existing data model for a Device Sync-enabled App Services App.
   :keywords: Realm, object model, C++ SDK, Flutter SDK, Java SDK, Kotlin SDK, .NET SDK, Node.js SDK, React Native SDK, Swift SDK

.. facet::
   :name: genre
   :values: reference

.. facet::
   :name: programming_language
   :values: shell, json

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. toctree::
   :titlesonly:
   :hidden:

   Update Data Model in Development </sync/data-model/update-data-model/update-data-model-development>
   Update Data Model in Production </sync/data-model/update-data-model/update-data-model-production>
   Migrate to Partner Collection Data Model </sync/data-model/update-data-model/migrate-schema-partner-collection>

You will most likely need to make changes to your app's
:ref:`data model <device-sync-data-model>` after you have defined it. For
example, while developing your app, you may realize that an existing
property should be required. Or while planning for a future release for your
production-level app, you determine that a feature requires a new object type.

In general, we refer to data model updates in the following terms:

What type of change are you making?
  We broadly categorize changes to a data model as being either *breaking* or
  *non-breaking*, depending on whether they break compatibility with your
  current model. These change types are discussed in more detail below, or you
  can check out the :ref:`breaking-change-quick-reference` section.

Where are you making the change?
  Because Device Sync requires a matching client-side SDK data model and
  server-side App Services schema, we discuss data model changes in terms of
  whether you update the *client side* or the *server side* first.
  Depending on the change you make, there are implications for which side
  you should update first and how you apply those same changes to the other
  side. This is discussed in more detail below.

Is your app in development or production?
  The recommended process for updating your data model also depends on whether
  you are updating an app in production or in development:

  - If your app is in development, you can use Device Sync's
    :ref:`Development Mode <development-mode>` feature to streamline data model
    changes, including breaking changes. To learn more, refer to
    :ref:`update-data-model-development-mode`.

  - If you are updating a production-level app, data model changes require
    additional planning to reduce the impact to existing clients. To learn more,
    refer to :ref:`update-data-model-production`.

Change Types
------------

Let's dive into the types of changes that you can make to your data model. There
are two main types: **breaking** and **non-breaking**. In short, breaking
changes break compatibility with your current data model and require additional
action to restore connectivity with existing clients. Non-breaking changes do
not.

For apps in production, there is an additional subset of breaking changes:
**schema versioning**. These changes create a backward-compatible schema
version, rather than fully breaking compatibility with previous models.

The following sections provide more detail on each of these types. Or you can
skip to the :ref:`breaking-change-quick-reference` section for a summary
overview.

.. _non-breaking-changes-overview:

Non-Breaking Changes
~~~~~~~~~~~~~~~~~~~~

Non-breaking changes maintain compatibility with your existing data model. You
can make a non-breaking change to your client or server-side schema, and client
devices can continue to sync data without interruption.

- **Non-Breaking Changes in Development:** While you develop your app with
  :ref:`Development Mode <development-mode>`, you can
  make non-breaking changes in your client code, and App Services automatically
  applies those changes to your server-side schema. To learn more, refer to
  :ref:`update-data-model-development-mode`.
- **Non-Breaking Changes in Production:** Once your app is in production, you
  can make non-breaking changes to your server-side schema, then manually update
  the corresponding client-side models without breaking compatibility for
  existing clients. To learn more, refer to :ref:`update-data-model-production`.

.. _breaking-changes-overview:

Breaking Changes
~~~~~~~~~~~~~~~~

Breaking changes break compatibility with your existing data model and require
you to :ref:`terminate and re-enable Device Sync <pause-or-terminate-sync>`.
This results in existing clients being unable to sync data until
they upgrade to the new data model and reconnect through a :ref:`client reset
<client-resets>`.

Development Mode streamlines this process for apps in development by letting you
make breaking changes without requiring you to terminate Sync. However,
Development Mode is not intended for production use and should not be enabled in
a production-level app. As a result, we recommend that you only make breaking
changes in a production app when necessary.

You can make breaking changes to your server-side schema or to your
client-side data model, but there are implications depending on the state of
your app and the change your making. Note that you cannot update your App
Services schema with breaking changes using the {+cli+} or automated deploy with
GitHub. You must use the App Services UI.

- **Breaking Changes in Development:** While you develop your app,
  :ref:`Development Mode <development-mode>` lets you make breaking changes to
  your client code, and App Services automatically handles overwriting
  your server-side schema without requiring you to terminate Sync. To learn
  more, refer to :ref:`update-data-model-development-mode`.
- **Breaking Changes in Production:** Once your app is in production, and you
  determine you need to make a breaking change, you can choose to either update
  your current data model directly or create a new data model with the changes:

  - If you choose to update your data model directly with a breaking change, you
    *must* terminate Device Sync, which breaks connectivity for all existing
    clients. To learn how to implement a breaking change and restore clients'
    ability to sync data, refer to :ref:`update-data-model-production`.
  - If you can't tolerate losing unsynced data or you need to maintain
    backward-compatibility with older clients that can't update, you can choose
    to migrate your existing data to a new "partner collection" schema with the
    desired changes. To learn how to implement this strategy, refer to
    :ref:`migrate-schema-partner-collection`.

.. _schema-versioning-changes-overview:

Schema Versioning Changes
~~~~~~~~~~~~~~~~~~~~~~~~~

Schema versioning changes are a special subset of breaking change for production
apps. These changes do not require you to terminate Device Sync or
manually perform a client reset.

Instead, the server creates a new backward-compatible version of your existing
schema, then automatically handles existing clients on older schemas
in a backward-compatible way. This ensures data consistency across schema
versions, as devices on older schema versions can still sync with the server and
other SDK devices.

To learn more, refer to :ref:`update-data-model-production`.

.. important:: Schema Versioning is Incompatible with Development Mode

   While :ref:`Development Mode <development-mode>` is enabled, App Services
   disables schema versioning in your app, and processes schema versioning
   changes as breaking changes.

   Additionally, if you enable Development Mode in an app with versioned
   schemas, App Services deletes all existing versions regardless of
   whether they are currently in use by an existing client. This will disrupt
   Sync for any client using a deleted version.

.. _breaking-change-quick-reference:

Update a Data Model: Quick Reference
------------------------------------

This section summarizes whether a data model change is considered a
non-breaking, schema versioning, or breaking change when made to the server-side
App Services schema or to the client-side SDK data model.

.. list-table::
   :header-rows: 1
   :stub-columns: 1

   * - Description of Change
     - Server-Side Schema
     - Client-Side Data Model
   * - :ref:`Add an object type <schema-update-add-object-type>`
     - Non-breaking
     - Non-breaking
   * - :ref:`Add a property <schema-update-add-required-property>`
     - Non-breaking
     - Non-breaking
   * - :ref:`Set a default value on a property <schema-update-add-a-default-value>`
     - Non-breaking
     - Non-breaking
   * - :ref:`Remove an object type <schema-update-remove-object-type>`
     - Schema Versioning*
     - Non-breaking
   * - :ref:`Remove a property <schema-update-remove-property>`
     - Schema Versioning*
     - Non-breaking
   * - :ref:`Change whether a property is optional or required <schema-update-change-property-status>`
     - Schema Versioning*
     - Breaking
   * - :ref:`Rename an object type <schema-update-change-object-type-name>`
     - Breaking
     - Breaking
   * - :ref:`Rename a property <schema-update-change-property-name>`
     - Breaking
     - Breaking
   * - :ref:`Change property data type <schema-update-change-property-type-but-keep-name>`
     - Breaking
     - Breaking

*If Development Mode is enabled in your app, schema versioning is disabled, and
App Services processes schema versioning changes as breaking changes.*

.. figure:: /images/data-model-changes-from-client-or-server.png
   :alt: Summary of data model changes when made from client or server side
   :lightbox:

.. _schema-update-add-object-type:

Add an Object Type
------------------

Adding an object type is a non-breaking change when made to the server-side
schema or the client-side SDK data model.

You can make your changes from the client or server side:

- **Client Side:** Use :ref:`Development Mode <development-mode>` to let App
  Services handle the server-side schema updates.
- **Server Side:** Manually add the object type to both the client model and the
  schema.

.. note:: May Cause Documents to Resync

  If you have existing documents in Atlas and you add a new object type, the
  server retrieves the documents in Atlas for the collection and re-inserts them
  to get the new values. This is expected behavior, but it does temporarily halt
  syncing changes until the process completes.

.. _schema-update-add-a-default-value:

Set a Default Value on a Property
---------------------------------

Setting a default value on an existing object property is a non-breaking change
when made to the server-side schema or the client-side SDK data model.

We recommend that you always set a default value to a property whenever you add
a new required property, either on its own or as a property for a new object
type.

You can make your changes from the client or server side:

- **Client Side:** Use :ref:`Development Mode <development-mode>` to let App
  Services handle the server-side schema updates.
- **Server Side:** Manually add the default value to the schema.

  If you have existing Atlas documents that are missing the value, the property
  remains empty until a synced client makes changes or you update the document
  directly in Atlas.

Set Default Value in App Services UI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To set a default value through the App Services UI:

#. Navigate to :guilabel:`Schemas` screen:

   .. include:: /includes/navigation/nav-to-schema-page.rst

#. Find and select the collection you want to edit the schema for, then toggle
   the editor view to ``JSON View``.

#. Update the JSON schema to set a default value for a given property, similar
   to ``"default": <value> ``.

   .. figure:: /images/set-default-value.png
      :alt: Setting default value using the Schema screen editor
      :lightbox:

.. warning:: Default Type Must Match the Property Type

   The default field does *not* have type validation. If the default field
   type and the property type are not the same, an error indicates that
   the document is missing a required field.

.. _schema-update-add-required-property:
.. _schema-update-add-optional-property:

Add a Required or Optional Property
-----------------------------------

Adding a new property is a non-breaking change when made to the server-side
schema or the client-side SDK data model. However, if you have existing Atlas
documents that may be impacted by this change, you should consider making the
property optional to avoid having to update them.

.. tip:: Always Set Default Values for Required Properties

  We recommend that you always set a default value when adding a required
  property.

  If you don't set a default value and a client doesn't include
  the added property, the server populates the missing required field with a
  zero or blank value (for example, 0, "", or 0.0 depending on the property
  type) when the document syncs.

You can make your changes from the client or server side:

- **Client Side:** Use :ref:`Development Mode <development-mode>` to let App
  Services handle the server-side schema updates.
- **Server Side:** Manually add the property to both the client model and the
  schema.

  If you have existing Atlas documents that are impacted by this change, you
  must update them with the new property or they cannot sync to the client.
  This may give client users the impression that the data has been lost.

.. important:: May Require Terminating Device Sync for Large Collections

  If you have existing documents in Atlas and you add a new property,
  the server retrieves the documents in Atlas for the collection and re-inserts
  them to get the new values. This is expected behavior, but the server temporarily halts syncing data until the process completes.

  However, if the amount of unsynced documents exceeds the limit of 100,000
  documents, you must :ref:`terminate and re-enable Device Sync
  <terminating-realm-sync>`, despite this being a non-breaking change. For more
  information, refer to :ref:`unsynced-documents`.

.. _schema-update-remove-object-type:

Remove an Object Type
---------------------

Removing an existing object type is handled differently depending on where you
make the change:

- **Client Side:** Removing an object type from the client-side model is
  considered a *non-breaking change*.

  You can either:

  - Use :ref:`Development Mode <development-mode>` to let App Services handle
    the server-side schema updates.
  - Manually remove the object type from the client model and leave it in place
    on the server-side schema.
- **Server Side:** Removing an object type from the server-side schema is a
  *schema versioning change*. You must manually add the object type to the
  schema, and App Services creates a backward-compatible schema version.

.. _schema-update-remove-property:

Remove a Property
-----------------

Removing an existing optional or required property is handled differently
depending on where you make the change:

- **Client Side:** Removing a property from the client-side SDK model is a
  *non-breaking change*.

  You can either:

  - Use :ref:`Development Mode <development-mode>` to let App Services handle
    the server-side schema updates.

  - Manually remove the property from the client model and leave it in place
    on the server-side schema. This does not delete the property from the
    database. Instead, new objects retain the removed property populated with a
    zero or blank value (for example, 0, "", ``null`` depending on the property
    type).
- **Server Side:** Removing a property from the server-side schema is a
  *schema versioning change*. You must manually add the property to the schema,
  and App Services creates a backward-compatible schema version.

.. _schema-update-change-property-status:

Change a Property's Status Between Optional and Required
--------------------------------------------------------

Changing the optionality of an existing property is handled differently
depending on where you make the change:

- **Client Side:** Changing the status of an existing property from the
  client-side model is considered a *breaking change*. Use :ref:`Development
  Mode <development-mode>` to let App Services handle the server-side schema
  updates. This requires you to delete all local data before connecting to the
  server again, but you don't have to terminate Device Sync. For more
  information, refer to :ref:`update-data-model-development-mode`.
- **Server Side:** Changing the status of an existing property from the
  server-side schema is a *schema versioning change*. You must manually update
  the schema, and App Services creates a backward-compatible schema version.

  If you have existing Atlas documents that are impacted by this change, you
  must update them with the updated property or they cannot sync to the client.
  This may give client users the impression that the data has been lost.

  To ensure the impacted documents can continue syncing to client devices, you
  can either:

  - Change the old field name on each document to match the new model
  - Add a new field to each document with a name that matches the new model,
    and populate it with the value from the old field

.. tip:: Always Set Default Values for Required Properties

   We recommend that you  set a default value when making a property required.

   If you don't set a default value and a client doesn't include
   the added property, the server populates the missing required field with a
   zero or blank value (for example, 0, "", or 0.0 depending on the property
   type) when the document syncs.

.. _schema-update-change-object-type-name:

Change an Object's Name
-----------------------

Renaming an object type is a breaking change to both the server-side schema and
the client-side object model. Unless you have Development Mode enabled, this
change requires you to terminate Device Sync and perform a client reset.

To avoid breaking your data model, consider the following alternatives to
renaming an object type:

- **Remap the name in the client.** If you are using one of the following Atlas
  Device SDK languages, you can avoid breaking your data model by remapping a
  new object or class name to your existing name. This effectively renames your
  client-side object while keeping the original name on the server, and avoids
  having to perform a client reset.

  Remapping an object or class name is supported in the following SDKs:

  - :ref:`Flutter SDK <flutter-map-property>`
  - :ref:`Java SDK <java-rename-object>`
  - :ref:`Kotlin SDK <kotlin-remap-a-property>`
  - :ref:`.NET SDK <dotnet-rename-object>`
  - :ref:`Node.js SDK <node-remap-a-property>`
  - :ref:`React Native SDK <react-native-remap-a-property>`

- **Create a partner collection.** Implementing a :ref:`partner collection
  strategy <schema-partner_collection-strategy>` lets you keep your existing
  collection and schema. Instead, you create a partner collection with the new
  schema definition in place and use database triggers to maintain writes to
  both collections.

If you choose to change the object's name, you can make your changes from the
client or server side:

- **Client Side:** Use :ref:`Development Mode <development-mode>` to let App
  Services handle the server-side schema updates. This requires you to delete
  all local data before connecting to the server again, but you don't have to
  terminate Device Sync. For more information,
  refer to :ref:`update-data-model-development-mode`.
- **Server Side:** Manually update the schema to reflect the new object name.
  This creates a new minimum schema version and requires you to :ref:`terminate
  and re-enable Device Sync <pause-or-terminate-sync>`, then perform a
  :ref:`client reset <client-resets>` to restore Sync.

.. _schema-update-change-property-name:

Change a Property Name
----------------------

Renaming a property is a breaking change to both the server-side schema and
the client-side object model. Unless you have Development Mode enabled, this
change requires you to terminate Device Sync and perform a client reset.

To avoid breaking your data model, consider the following alternatives to
renaming an existing property:

- **Remap the name in the client.** If you are using one of the following Atlas
  Device SDK languages, you can avoid breaking your data model by remapping a
  new property name to your existing name. This effectively renames your
  client-side property while keeping the original name on the server, and avoids
  having to perform a client reset.

  Remapping property name is supported in the following SDKs:

- :ref:`Flutter SDK <flutter-map-property>`
- :ref:`Java SDK <java-rename-field>`
- :ref:`Kotlin SDK <kotlin-remap-a-property>`
- :ref:`.NET SDK <dotnet-rename-property>`
- :ref:`Node.js SDK <node-remap-a-property>`
- :ref:`React Native SDK <react-native-remap-a-property>`
- :ref:`Swift SDK <swift-rename-property>`

- **Create a partner collection.** Implementing a :ref:`partner collection
  strategy <schema-partner_collection-strategy>` lets you keep your existing
  collection and schema. Instead, you create a partner collection with the new
  schema definition in place and use database triggers to maintain writes to
  both collections.

If you choose to change the property's name, you can make your changes from the client or server side:

- **Client Side:** Use :ref:`Development Mode <development-mode>` to let App
  Services handle the server-side schema updates. This requires you to delete
  all local data before connecting to the server again, but you don't have to
  terminate Device Sync. For more information,
  refer to :ref:`update-data-model-development-mode`.
- **Server Side:** Manually update the schema to reflect the new object name.
  This creates a new minimum schema version and requires you to :ref:`terminate
  and re-enable Device Sync <pause-or-terminate-sync>`, then perform a
  :ref:`client reset <client-resets>` to restore Sync.

  If you have existing Atlas documents that are impacted by this change, you
  must update them with the new property or they cannot sync to the client.
  This may give client users the impression that the data has been lost.

  To ensure the impacted documents can continue syncing to client devices, you
  can either:

  - Change the old field name on each document to match the new model
  - Add a new field to each document with a name that matches the new model,
    and populate it with the value from the old field

.. _schema-update-change-property-type-but-keep-name:

Change a Property Data Type
---------------------------

Changing the data type of an existing property is a breaking change to both the
server-side schema and the client-side object model. Unless you have Development
Mode enabled, this change requires you to terminate Device Sync and perform a
client reset.

To avoid breaking your data model, consider implementing a :ref:`partner
collection strategy <schema-partner_collection-strategy>`, where you create a
partner collection with the new schema definition in place and use database
triggers to maintain writes to it and your existing collection.

If you choose to change the property's data type, you can make your changes from
the client or server side:

- **Client Side:** Use :ref:`Development Mode <development-mode>` to let App
  Services handle the server-side schema updates. This requires you to delete
  all local data before connecting to the server again, but you don't have to
  terminate Device Sync. For more information,
  refer to :ref:`update-data-model-development-mode`.
- **Server Side:** Manually update the schema to reflect the new data type.
  This creates a new minimum schema version and requires you to :ref:`terminate
  and re-enable Device Sync <pause-or-terminate-sync>`, then perform a
  :ref:`client reset <client-resets>` to restore Sync.

  If you have existing Atlas documents that are impacted by this change, you
  must update them with the new data type or they cannot sync to the client.
  This may give client users the impression that the data has been lost.

  To ensure the impacted documents can continue syncing to client devices, you
  can either:

  - Change the old field name on each document to match the new model
  - Add a new field to each document with the type that matches the new model,
    and populate it with the value from the old field
