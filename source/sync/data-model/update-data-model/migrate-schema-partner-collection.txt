.. _migrate-schema-partner-collection:
.. _schema-partner_collection-strategy:
.. _partner_collections:

==========================================
Migrate Data Model to a Partner Collection
==========================================

.. meta::
   :description: Apply breaking data model changes using the partner collection strategy for a Device Sync-enabled production app.
   :keywords: Realm

.. facet::
   :name: genre
   :values: reference

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Updating a production app's data model with breaking changes requires
terminating and re-enabling Device Sync, then manually restoring connectivity
with existing clients through a client reset. This process risks significant
downtime and potential data loss for existing clients.

An alternative approach to updating your data model directly is to create a new
"partner collection" with the breaking changes.

You may prefer this approach if:

- You can't tolerate losing unsynced data as a result of a client reset.
- You need to maintain backward compatibility with older clients that can't update.

If you prefer to update your production app's data model directly, refer to
:ref:`update-data-model-production`.

.. note:: Not Intended for Apps in Development

   These constraints and strategies apply specifically to apps in production. If
   your app is still in development, we highly recommend that you use
   Development Mode. This lets you make breaking changes directly in your client
   code without requiring additional action. For more information, refer to
   :ref:`update-data-model-development-mode`.

Partner Collections
-------------------

A **partner collection** is a separate Atlas collection that mirrors an existing
collection already storing synced data for your app. When you create the partner
collection, you can define its schema with the desired changes that would break
your existing collection's schema if you applied them directly.

After you create the partner collection, you can copy the data from the existing
collection, then set up database triggers to keep the data in sync between the
two collections.

Create a Partner Collection
---------------------------

The following procedure walks through creating a new ``TaskV2`` partner
collection for an existing ``Task`` collection.

This is because We need to make a breaking change to our existing data model: we want to change the data type of the ``_id`` field from ``objectId`` to ``string``. This change is not backward-compatible with existing clients, so we create a new partner collection with the change implemented.

.. code-block:: json
    :caption: Schema for initial collection
    :emphasize-lines: 9-10

    {
        "title": "Task",
        "bsonType": "object",
        "required": [
            "_id",
            "name"
        ],
        "properties": {
            "_id": {
                "bsonType": "objectId"
            },
            "name": {
                "bsonType": "string"
            },
            "complete": {
                "bsonType": "boolean",
                "default": false
            }
        }
    }

Because this is a breaking change to our existing data model, we create a new ``TaskV2`` partner collection with the change implemented:

.. code-block:: json
    :caption: Schema for partner collection
    :emphasize-lines: 9-10

    {
        "title": "Task",
        "bsonType": "object",
        "required": [
            "_id",
            "name"
        ],
        "properties": {
            "_id": {
                "bsonType": "string"
            },
            "name": {
                "bsonType": "string"
            },
            "complete": {
                "bsonType": "boolean",
                "default": false
            }
        }
    }

.. procedure::

   .. step:: Initialize Your Partner Collection with an Aggregation Pipeline

      Because breaking changes cannot be performed directly on a synced object
      schema, you must create a partner collection with a schema containing the
      required changes. You must ensure that the partner collection has the same
      data as the original collection so that newer clients can synchronize with
      older clients.

      The recommended approach to copy the data from your original collection to
      the new partner collection is to use the :manual:`Aggregation Framework
      </aggregation/>`.

      You can create and run an aggregation pipeline from the
      `mongo shell <https://www.mongodb.com/docs/mongodb-shell/>`__,
      by using the :compass:`</aggregation-pipeline-builder/>` or with the
      :atlas:`</data-explorer/cloud-agg-pipeline/>`.

      The pipeline will have the following stages:

      1. Match all the documents in the initial collection by passing
         an empty filter to the :manual:`$match operator
         </reference/operator/aggregation/match/>`.

      2. Modify the fields of the initial collection using an
         :manual:`aggregation pipeline operator </reference/operator/aggregation/>`. In
         the following example, the data is transformed using the :manual:`$addFields
         operator </reference/operator/aggregation/addFields/>`. The ``_id`` field is
         transformed to a ``string`` type with the :manual:`$toString operator
         </reference/operator/aggregation/toString/>`.

      3. Write the transformed data to the partner collection using the
         :manual:`$out operator </reference/operator/aggregation/out/>` and specifying
         the partner collection name. In this example, we wrote the data to a new
         collection named ``TaskV2``.

      Here the same pipeline is represented in the Atlas and Compass UIs. Note that
      both of these tools provide a preview of the changes; in this case, the
      conversion the ``_id`` field from an ObjectId to a string:

      .. figure:: /images/agg-in-atlas.png
         :alt: Atlas UI for Aggregation Builder
         :lightbox:

      The following example shows the complete aggregation pipeline if you used :mongosh:`mongosh </>` to do the conversion:

      .. code-block:: shell
         :caption: Match all documents in initial collection, then output to partner collection

         use "<database-name>" // switch to db the Task collection is stored in
         collection = db.Task;
         collection.aggregate([
           { $match: {} }, // match all documents in the Task collection
           {
             $addFields: { // transform the data
               _id: { $toString: "$_id" }, // change _id field to string type
             },
           },
           { $out: "TaskV2" }, // output the data to partner collection
         ]);

   .. step:: Set up Database Triggers for Your Partner Collections

      Once your partner collection is set up, you can use it to read existing data.
      However, any new writes to the data of *either collection* will not be
      in the other collection. This causes the old clients to be out of sync with the
      new clients.

      To ensure that data is reflected in both collections, you set up a
      :ref:`database trigger <create-a-database-trigger>` on each collection. When
      data is written to one collection, the trigger's function performs the write
      to the partner collection.

      Follow the steps in the :ref:`database trigger <create-a-database-trigger>`
      documentation to create a trigger that copies data from the ``Task`` collection to
      the ``TaskV2`` collection for all operation types. Repeat these steps to create
      a second trigger that copies data from the ``TaskV2`` collection to the
      ``Task`` collection.

   .. step:: Add Trigger Functions

      Triggers require backing functions that run when the trigger fires. In this
      case, we need to create two functions: a forward-migration function and a
      reverse-migration function.

      The forward migration trigger listens for inserts, updates, and deletes in the
      Task collection, modifies them to reflect the TaskV2 collection's schema, and
      then applies them to the ``TaskV2`` collection.

      To listen for changes to the ``TaskV2`` collection and apply them to the Task
      collection, write a reverse-migration function for the ``TaskV2`` collection's
      trigger. The reverse migration follows the same idea as the previous step.

      In the forward-migration function, we check which operation has triggered the
      function: if the operation type is ``Delete`` (meaning a document
      has been deleted in the Task collection), the document is also deleted in the
      ``TaskV2`` collection. If the operation type is a ``Write`` (inserted or modified)
      event, an aggregation pipeline is created. In the pipeline, the inserted or
      modified document in the ``Task`` collection is extracted using the
      :manual:`$match operator </reference/operator/aggregation/match/>`. The
      extracted document is then transformed to adhere to the
      ``TaskV2`` collection's schema. Finally, the transformed data is written to the
      ``TaskV2`` collection by using the
      :manual:`$merge operator </reference/operator/aggregation/merge/>`:

      .. literalinclude:: /examples/generated/functions/copyTaskObjectToTaskV2.codeblock.copyTaskObject.js
         :language: javascript
         :caption: copyTaskObjectToTaskV2 function

      The reverse-migration function goes through similar steps as the example in the
      prior step. If a document has been deleted in one collection, the document is
      also deleted in the other collection. If the operation type is a write event,
      the changed document from ``TaskV2`` is extracted, transformed to match the
      ``Task`` collection's schema, and written into the ``Task`` collection:

      .. literalinclude:: /examples/generated/functions/copyTaskV2ObjectToTask.codeblock.copyTaskV2Object.js
         :language: javascript
         :caption: copyTaskV2ObjectToTask function

